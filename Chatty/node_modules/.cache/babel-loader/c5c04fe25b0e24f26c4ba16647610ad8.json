{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Namespace = void 0;\n\nconst socket_1 = require(\"./socket\");\n\nconst events_1 = require(\"events\");\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"socket.io:namespace\");\n\nclass Namespace extends events_1.EventEmitter {\n  /**\n   * Namespace constructor.\n   *\n   * @param {Server} server instance\n   * @param {string} name\n   */\n  constructor(server, name) {\n    super();\n    this.sockets = new Map();\n    /** @private */\n\n    this._fns = [];\n    /** @private */\n\n    this._rooms = new Set();\n    /** @private */\n\n    this._flags = {};\n    /** @private */\n\n    this._ids = 0;\n    this.server = server;\n    this.name = name;\n\n    this._initAdapter();\n  }\n  /**\n   * Initializes the `Adapter` for this nsp.\n   * Run upon changing adapter by `Server#adapter`\n   * in addition to the constructor.\n   *\n   * @private\n   */\n\n\n  _initAdapter() {\n    this.adapter = new (this.server.adapter())(this);\n  }\n  /**\n   * Sets up namespace middleware.\n   *\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  use(fn) {\n    this._fns.push(fn);\n\n    return this;\n  }\n  /**\n   * Executes the middleware for an incoming client.\n   *\n   * @param {Socket} socket - the socket that will get added\n   * @param {Function} fn - last fn call in the middleware\n   * @private\n   */\n\n\n  run(socket, fn) {\n    const fns = this._fns.slice(0);\n\n    if (!fns.length) return fn(null);\n\n    function run(i) {\n      fns[i](socket, function (err) {\n        // upon error, short-circuit\n        if (err) return fn(err); // if no middleware left, summon callback\n\n        if (!fns[i + 1]) return fn(null); // go on to next\n\n        run(i + 1);\n      });\n    }\n\n    run(0);\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param {String} name\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  to(name) {\n    this._rooms.add(name);\n\n    return this;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param {String} name\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  in(name) {\n    this._rooms.add(name);\n\n    return this;\n  }\n  /**\n   * Adds a new client.\n   *\n   * @return {Socket}\n   * @private\n   */\n\n\n  _add(client, query, fn) {\n    debug(\"adding socket to nsp %s\", this.name);\n    const socket = new socket_1.Socket(this, client, query);\n    this.run(socket, err => {\n      process.nextTick(() => {\n        if (\"open\" == client.conn.readyState) {\n          if (err) return socket._error({\n            message: err.message,\n            data: err.data\n          }); // track socket\n\n          this.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic\n          // fires before user-set events to prevent state order\n          // violations (such as a disconnection before the connection\n          // logic is complete)\n\n          socket._onconnect();\n\n          if (fn) fn(); // fire user-set events\n\n          super.emit(\"connect\", socket);\n          super.emit(\"connection\", socket);\n        } else {\n          debug(\"next called after client was closed - ignoring socket\");\n        }\n      });\n    });\n    return socket;\n  }\n  /**\n   * Removes a client. Called by each `Socket`.\n   *\n   * @private\n   */\n\n\n  _remove(socket) {\n    if (this.sockets.has(socket.id)) {\n      this.sockets.delete(socket.id);\n    } else {\n      debug(\"ignoring remove for %s\", socket.id);\n    }\n  }\n  /**\n   * Emits to all clients.\n   *\n   * @return {Boolean} Always true\n   * @public\n   */\n\n\n  emit(ev, ...args) {\n    if (socket_1.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${ev}\" is a reserved event name`);\n    } // set up packet object\n\n\n    args.unshift(ev);\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: args\n    };\n\n    if (\"function\" == typeof args[args.length - 1]) {\n      throw new Error(\"Callbacks are not supported when broadcasting\");\n    }\n\n    const rooms = new Set(this._rooms);\n    const flags = Object.assign({}, this._flags); // reset flags\n\n    this._rooms.clear();\n\n    this._flags = {};\n    this.adapter.broadcast(packet, {\n      rooms: rooms,\n      flags: flags\n    });\n    return true;\n  }\n  /**\n   * Sends a `message` event to all clients.\n   *\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  send(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  /**\n   * Sends a `message` event to all clients.\n   *\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  write(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  /**\n   * Gets a list of clients.\n   *\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  allSockets() {\n    if (!this.adapter) {\n      throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n    }\n\n    const rooms = new Set(this._rooms);\n\n    this._rooms.clear();\n\n    return this.adapter.sockets(rooms);\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param {Boolean} compress - if `true`, compresses the sending data\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  compress(compress) {\n    this._flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  get volatile() {\n    this._flags.volatile = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @return {Namespace} self\n   * @public\n   */\n\n\n  get local() {\n    this._flags.local = true;\n    return this;\n  }\n\n}\n\nexports.Namespace = Namespace;","map":null,"metadata":{},"sourceType":"script"}