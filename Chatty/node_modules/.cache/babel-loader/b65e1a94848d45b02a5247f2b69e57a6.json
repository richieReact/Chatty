{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = exports.RESERVED_EVENTS = void 0;\n\nconst events_1 = require(\"events\");\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nconst url = require(\"url\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst base64id_1 = __importDefault(require(\"base64id\"));\n\nconst debug = debug_1.default(\"socket.io:socket\");\nexports.RESERVED_EVENTS = new Set([\"connect\", \"connect_error\", \"disconnect\", \"disconnecting\", // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n\"newListener\", \"removeListener\"]);\n\nclass Socket extends events_1.EventEmitter {\n  /**\n   * Interface to a `Client` for a given `Namespace`.\n   *\n   * @param {Namespace} nsp\n   * @param {Client} client\n   * @param {Object} auth\n   * @package\n   */\n  constructor(nsp, client, auth) {\n    super();\n    this.nsp = nsp;\n    this.client = client;\n    this.acks = new Map();\n    this.fns = [];\n    this.flags = {};\n    this._rooms = new Set();\n    this.server = nsp.server;\n    this.adapter = this.nsp.adapter;\n    this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n\n    this.connected = true;\n    this.disconnected = false;\n    this.handshake = this.buildHandshake(auth);\n  }\n  /**\n   * Builds the `handshake` BC object\n   *\n   * @private\n   */\n\n\n  buildHandshake(auth) {\n    return {\n      headers: this.request.headers,\n      time: new Date() + \"\",\n      address: this.conn.remoteAddress,\n      xdomain: !!this.request.headers.origin,\n      // @ts-ignore\n      secure: !!this.request.connection.encrypted,\n      issued: +new Date(),\n      url: this.request.url,\n      query: url.parse(this.request.url, true).query,\n      auth\n    };\n  }\n  /**\n   * Emits to this client.\n   *\n   * @return {Boolean} Always true\n   * @public\n   */\n\n\n  emit(ev, ...args) {\n    if (exports.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${ev}\" is a reserved event name`);\n    }\n\n    args.unshift(ev);\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: args\n    }; // access last argument to see if it's an ACK callback\n\n    if (typeof args[args.length - 1] === \"function\") {\n      if (this._rooms.size || this.flags.broadcast) {\n        throw new Error(\"Callbacks are not supported when broadcasting\");\n      }\n\n      debug(\"emitting packet with ack id %d\", this.nsp._ids);\n      this.acks.set(this.nsp._ids, args.pop());\n      packet.id = this.nsp._ids++;\n    }\n\n    const rooms = new Set(this._rooms);\n    const flags = Object.assign({}, this.flags); // reset flags\n\n    this._rooms.clear();\n\n    this.flags = {};\n\n    if (rooms.size || flags.broadcast) {\n      this.adapter.broadcast(packet, {\n        except: new Set([this.id]),\n        rooms: rooms,\n        flags: flags\n      });\n    } else {\n      // dispatch packet\n      this.packet(packet, flags);\n    }\n\n    return true;\n  }\n  /**\n   * Targets a room when broadcasting.\n   *\n   * @param {String} name\n   * @return {Socket} self\n   * @public\n   */\n\n\n  to(name) {\n    this._rooms.add(name);\n\n    return this;\n  }\n  /**\n   * Targets a room when broadcasting.\n   *\n   * @param {String} name\n   * @return {Socket} self\n   * @public\n   */\n\n\n  in(name) {\n    this._rooms.add(name);\n\n    return this;\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * @return {Socket} self\n   * @public\n   */\n\n\n  send(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * @return {Socket} self\n   * @public\n   */\n\n\n  write(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  /**\n   * Writes a packet.\n   *\n   * @param {Object} packet - packet object\n   * @param {Object} opts - options\n   * @private\n   */\n\n\n  packet(packet, opts = {}) {\n    packet.nsp = this.nsp.name;\n    opts.compress = false !== opts.compress;\n\n    this.client._packet(packet, opts);\n  }\n  /**\n   * Joins a room.\n   *\n   * @param {String|Array} rooms - room or array of rooms\n   * @return a Promise or nothing, depending on the adapter\n   * @public\n   */\n\n\n  join(rooms) {\n    debug(\"join room %s\", rooms);\n    return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n  }\n  /**\n   * Leaves a room.\n   *\n   * @param {String} room\n   * @return a Promise or nothing, depending on the adapter\n   * @public\n   */\n\n\n  leave(room) {\n    debug(\"leave room %s\", room);\n    return this.adapter.del(this.id, room);\n  }\n  /**\n   * Leave all rooms.\n   *\n   * @private\n   */\n\n\n  leaveAll() {\n    this.adapter.delAll(this.id);\n  }\n  /**\n   * Called by `Namespace` upon successful\n   * middleware execution (ie: authorization).\n   * Socket is added to namespace array before\n   * call to join, so adapters can access it.\n   *\n   * @private\n   */\n\n\n  _onconnect() {\n    debug(\"socket connected - writing packet\");\n    this.join(this.id);\n    this.packet({\n      type: socket_io_parser_1.PacketType.CONNECT,\n      data: {\n        sid: this.id\n      }\n    });\n  }\n  /**\n   * Called with each packet. Called by `Client`.\n   *\n   * @param {Object} packet\n   * @private\n   */\n\n\n  _onpacket(packet) {\n    debug(\"got packet %j\", packet);\n\n    switch (packet.type) {\n      case socket_io_parser_1.PacketType.EVENT:\n        this.onevent(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.ACK:\n        this.onack(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n\n      case socket_io_parser_1.PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n\n      case socket_io_parser_1.PacketType.CONNECT_ERROR:\n        this._onerror(new Error(packet.data));\n\n    }\n  }\n  /**\n   * Called upon event packet.\n   *\n   * @param {Object} packet - packet object\n   * @private\n   */\n\n\n  onevent(packet) {\n    const args = packet.data || [];\n    debug(\"emitting event %j\", args);\n\n    if (null != packet.id) {\n      debug(\"attaching ack callback to event\");\n      args.push(this.ack(packet.id));\n    }\n\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n\n    super.emit.apply(this, args);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @param {Number} id - packet id\n   * @private\n   */\n\n\n  ack(id) {\n    const self = this;\n    let sent = false;\n    return function () {\n      // prevent double callbacks\n      if (sent) return;\n      const args = Array.prototype.slice.call(arguments);\n      debug(\"sending ack %j\", args);\n      self.packet({\n        id: id,\n        type: socket_io_parser_1.PacketType.ACK,\n        data: args\n      });\n      sent = true;\n    };\n  }\n  /**\n   * Called upon ack packet.\n   *\n   * @private\n   */\n\n\n  onack(packet) {\n    const ack = this.acks.get(packet.id);\n\n    if (\"function\" == typeof ack) {\n      debug(\"calling ack %s with %j\", packet.id, packet.data);\n      ack.apply(this, packet.data);\n      this.acks.delete(packet.id);\n    } else {\n      debug(\"bad ack %s\", packet.id);\n    }\n  }\n  /**\n   * Called upon client disconnect packet.\n   *\n   * @private\n   */\n\n\n  ondisconnect() {\n    debug(\"got disconnect packet\");\n\n    this._onclose(\"client namespace disconnect\");\n  }\n  /**\n   * Handles a client error.\n   *\n   * @private\n   */\n\n\n  _onerror(err) {\n    if (this.listeners(\"error\").length) {\n      super.emit(\"error\", err);\n    } else {\n      console.error(\"Missing error handler on `socket`.\");\n      console.error(err.stack);\n    }\n  }\n  /**\n   * Called upon closing. Called by `Client`.\n   *\n   * @param {String} reason\n   * @throw {Error} optional error object\n   *\n   * @private\n   */\n\n\n  _onclose(reason) {\n    if (!this.connected) return this;\n    debug(\"closing socket - reason %s\", reason);\n    super.emit(\"disconnecting\", reason);\n    this.leaveAll();\n\n    this.nsp._remove(this);\n\n    this.client._remove(this);\n\n    this.connected = false;\n    this.disconnected = true;\n    super.emit(\"disconnect\", reason);\n  }\n  /**\n   * Produces an `error` packet.\n   *\n   * @param {Object} err - error object\n   *\n   * @private\n   */\n\n\n  _error(err) {\n    this.packet({\n      type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n      data: err\n    });\n  }\n  /**\n   * Disconnects this client.\n   *\n   * @param {Boolean} close - if `true`, closes the underlying connection\n   * @return {Socket} self\n   *\n   * @public\n   */\n\n\n  disconnect(close = false) {\n    if (!this.connected) return this;\n\n    if (close) {\n      this.client._disconnect();\n    } else {\n      this.packet({\n        type: socket_io_parser_1.PacketType.DISCONNECT\n      });\n\n      this._onclose(\"server namespace disconnect\");\n    }\n\n    return this;\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param {Boolean} compress - if `true`, compresses the sending data\n   * @return {Socket} self\n   * @public\n   */\n\n\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @return {Socket} self\n   * @public\n   */\n\n\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n   * sender.\n   *\n   * @return {Socket} self\n   * @public\n   */\n\n\n  get broadcast() {\n    this.flags.broadcast = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @return {Socket} self\n   * @public\n   */\n\n\n  get local() {\n    this.flags.local = true;\n    return this;\n  }\n  /**\n   * A reference to the request that originated the underlying Engine.IO Socket.\n   *\n   * @public\n   */\n\n\n  get request() {\n    return this.client.request;\n  }\n  /**\n   * A reference to the underlying Client transport connection (Engine.IO Socket object).\n   *\n   * @public\n   */\n\n\n  get conn() {\n    return this.client.conn;\n  }\n  /**\n   * @public\n   */\n\n\n  get rooms() {\n    return this.adapter.socketRooms(this.id) || new Set();\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n\n    this._anyListeners.push(listener);\n\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n\n    this._anyListeners.unshift(listener);\n\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @param listener\n   * @public\n   */\n\n\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n\n    if (listener) {\n      const listeners = this._anyListeners;\n\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   *\n   * @public\n   */\n\n\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n\n}\n\nexports.Socket = Socket;","map":null,"metadata":{},"sourceType":"script"}