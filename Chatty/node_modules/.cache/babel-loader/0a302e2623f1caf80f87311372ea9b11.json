{"ast":null,"code":"const Transport = require(\"../transport\");\n\nconst parser = require(\"engine.io-parser\");\n\nconst zlib = require(\"zlib\");\n\nconst accepts = require(\"accepts\");\n\nconst debug = require(\"debug\")(\"engine:polling\");\n\nconst compressionMethods = {\n  gzip: zlib.createGzip,\n  deflate: zlib.createDeflate\n};\n\nclass Polling extends Transport {\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  constructor(req) {\n    super(req);\n    this.closeTimeout = 30 * 1000;\n    this.maxHttpBufferSize = null;\n    this.httpCompression = null;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"polling\";\n  }\n  /**\n   * Overrides onRequest.\n   *\n   * @param {http.IncomingMessage}\n   * @api private\n   */\n\n\n  onRequest(req) {\n    const res = req.res;\n\n    if (\"GET\" === req.method) {\n      this.onPollRequest(req, res);\n    } else if (\"POST\" === req.method) {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeHead(500);\n      res.end();\n    }\n  }\n  /**\n   * The client sends a request awaiting for us to send data.\n   *\n   * @api private\n   */\n\n\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\"); // assert: this.res, '.req and .res should be (un)set together'\n\n      this.onError(\"overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    debug(\"setting request\");\n    this.req = req;\n    this.res = res;\n    const self = this;\n\n    function onClose() {\n      self.onError(\"poll connection closed prematurely\");\n    }\n\n    function cleanup() {\n      req.removeListener(\"close\", onClose);\n      self.req = self.res = null;\n    }\n\n    req.cleanup = cleanup;\n    req.on(\"close\", onClose);\n    this.writable = true;\n    this.emit(\"drain\"); // if we're still writable but had a pending close, trigger an empty send\n\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n  }\n  /**\n   * The client sends a request with data.\n   *\n   * @api private\n   */\n\n\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    this.dataReq = req;\n    this.dataRes = res;\n    let chunks = \"\";\n    const self = this;\n\n    function cleanup() {\n      req.removeListener(\"data\", onData);\n      req.removeListener(\"end\", onEnd);\n      req.removeListener(\"close\", onClose);\n      self.dataReq = self.dataRes = chunks = null;\n    }\n\n    function onClose() {\n      cleanup();\n      self.onError(\"data request connection closed prematurely\");\n    }\n\n    function onData(data) {\n      let contentLength;\n      chunks += data;\n      contentLength = Buffer.byteLength(chunks);\n\n      if (contentLength > self.maxHttpBufferSize) {\n        chunks = \"\";\n        req.connection.destroy();\n      }\n    }\n\n    function onEnd() {\n      self.onData(chunks);\n      const headers = {\n        // text/html is required instead of text/plain to avoid an\n        // unwanted download dialog on certain user-agents (GH-43)\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": 2\n      };\n      res.writeHead(200, self.headers(req, headers));\n      res.end(\"ok\");\n      cleanup();\n    }\n\n    req.on(\"close\", onClose);\n    req.setEncoding(\"utf8\");\n    req.on(\"data\", onData);\n    req.on(\"end\", onEnd);\n  }\n  /**\n   * Processes the incoming data payload.\n   *\n   * @param {String} encoded payload\n   * @api private\n   */\n\n\n  onData(data) {\n    debug('received \"%s\"', data);\n    const self = this;\n\n    const callback = function (packet) {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        self.onClose();\n        return false;\n      }\n\n      self.onPacket(packet);\n    };\n\n    parser.decodePayload(data).forEach(callback);\n  }\n  /**\n   * Overrides onClose.\n   *\n   * @api private\n   */\n\n\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n\n    super.onClose();\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n\n\n  send(packets) {\n    this.writable = false;\n\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({\n        type: \"close\"\n      });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n\n    const self = this;\n    parser.encodePayload(packets, data => {\n      const compress = packets.some(function (packet) {\n        return packet.options && packet.options.compress;\n      });\n      self.write(data, {\n        compress: compress\n      });\n    });\n  }\n  /**\n   * Writes data as response to poll request.\n   *\n   * @param {String} data\n   * @param {Object} options\n   * @api private\n   */\n\n\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    const self = this;\n    this.doWrite(data, options, function () {\n      self.req.cleanup();\n    });\n  }\n  /**\n   * Performs the write.\n   *\n   * @api private\n   */\n\n\n  doWrite(data, options, callback) {\n    const self = this; // explicit UTF-8 is required for pages not served under utf\n\n    const isString = typeof data === \"string\";\n    const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n    const headers = {\n      \"Content-Type\": contentType\n    };\n\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n\n    const len = isString ? Buffer.byteLength(data) : data.length;\n\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n\n    this.compress(data, encoding, function (err, data) {\n      if (err) {\n        self.res.writeHead(500);\n        self.res.end();\n        callback(err);\n        return;\n      }\n\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n\n    function respond(data) {\n      headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n      self.res.writeHead(200, self.headers(self.req, headers));\n      self.res.end(data);\n      callback();\n    }\n  }\n  /**\n   * Compresses data.\n   *\n   * @api private\n   */\n\n\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n    const buffers = [];\n    let nread = 0;\n    compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }).on(\"end\", function () {\n      callback(null, Buffer.concat(buffers, nread));\n    }).end(data);\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n\n\n  doClose(fn) {\n    debug(\"closing\");\n    const self = this;\n    let closeTimeoutTimer;\n\n    if (this.dataReq) {\n      debug(\"aborting ongoing data request\");\n      this.dataReq.destroy();\n    }\n\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{\n        type: \"close\"\n      }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n\n    function onClose() {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      self.onClose();\n    }\n  }\n  /**\n   * Returns headers for a response.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {Object} extra headers\n   * @api private\n   */\n\n\n  headers(req, headers) {\n    headers = headers || {}; // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n\n    const ua = req.headers[\"user-agent\"];\n\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n\n    this.emit(\"headers\", headers);\n    return headers;\n  }\n\n}\n\nmodule.exports = Polling;","map":null,"metadata":{},"sourceType":"script"}