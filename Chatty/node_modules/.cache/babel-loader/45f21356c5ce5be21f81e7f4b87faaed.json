{"ast":null,"code":"const EventEmitter = require(\"events\");\n\nconst debug = require(\"debug\")(\"engine:socket\");\n\nclass Socket extends EventEmitter {\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  constructor(id, server, transport, req) {\n    super();\n    this.id = id;\n    this.server = server;\n    this.upgrading = false;\n    this.upgraded = false;\n    this.readyState = \"opening\";\n    this.writeBuffer = [];\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.cleanupFn = [];\n    this.request = req; // Cache IP since it might not be in the req later\n\n    if (req.websocket && req.websocket._socket) {\n      this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    this.checkIntervalTimer = null;\n    this.upgradeTimeoutTimer = null;\n    this.pingTimeoutTimer = null;\n    this.pingIntervalTimer = null;\n    this.setTransport(transport);\n    this.onOpen();\n  }\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n\n\n  onOpen() {\n    this.readyState = \"open\"; // sends an `open` packet\n\n    this.transport.sid = this.id;\n    this.sendPacket(\"open\", JSON.stringify({\n      sid: this.id,\n      upgrades: this.getAvailableUpgrades(),\n      pingInterval: this.server.opts.pingInterval,\n      pingTimeout: this.server.opts.pingTimeout\n    }));\n\n    if (this.server.opts.initialPacket) {\n      this.sendPacket(\"message\", this.server.opts.initialPacket);\n    }\n\n    this.emit(\"open\");\n    this.schedulePing();\n  }\n  /**\n   * Called upon transport packet.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n\n\n  onPacket(packet) {\n    if (\"open\" === this.readyState) {\n      // export packet event\n      debug(\"packet\");\n      this.emit(\"packet\", packet); // Reset ping timeout on any packet, incoming data is a good sign of\n      // other side's liveness\n\n      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n\n      switch (packet.type) {\n        case \"pong\":\n          debug(\"got pong\");\n          this.schedulePing();\n          this.emit(\"heartbeat\");\n          break;\n\n        case \"error\":\n          this.onClose(\"parse error\");\n          break;\n\n        case \"message\":\n          this.emit(\"data\", packet.data);\n          this.emit(\"message\", packet.data);\n          break;\n      }\n    } else {\n      debug(\"packet received with closed socket\");\n    }\n  }\n  /**\n   * Called upon transport error.\n   *\n   * @param {Error} error object\n   * @api private\n   */\n\n\n  onError(err) {\n    debug(\"transport error\");\n    this.onClose(\"transport error\", err);\n  }\n  /**\n   * Pings client every `this.pingInterval` and expects response\n   * within `this.pingTimeout` or closes connection.\n   *\n   * @api private\n   */\n\n\n  schedulePing() {\n    clearTimeout(this.pingIntervalTimer);\n    this.pingIntervalTimer = setTimeout(() => {\n      debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n      this.sendPacket(\"ping\");\n      this.resetPingTimeout(this.server.opts.pingTimeout);\n    }, this.server.opts.pingInterval);\n  }\n  /**\n   * Resets ping timeout.\n   *\n   * @api private\n   */\n\n\n  resetPingTimeout(timeout) {\n    clearTimeout(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = setTimeout(() => {\n      if (this.readyState === \"closed\") return;\n      this.onClose(\"ping timeout\");\n    }, timeout);\n  }\n  /**\n   * Attaches handlers for the given transport.\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n\n\n  setTransport(transport) {\n    const onError = this.onError.bind(this);\n    const onPacket = this.onPacket.bind(this);\n    const flush = this.flush.bind(this);\n    const onClose = this.onClose.bind(this, \"transport close\");\n    this.transport = transport;\n    this.transport.once(\"error\", onError);\n    this.transport.on(\"packet\", onPacket);\n    this.transport.on(\"drain\", flush);\n    this.transport.once(\"close\", onClose); // this function will manage packet events (also message callbacks)\n\n    this.setupSendCallback();\n    this.cleanupFn.push(function () {\n      transport.removeListener(\"error\", onError);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"drain\", flush);\n      transport.removeListener(\"close\", onClose);\n    });\n  }\n  /**\n   * Upgrades socket to the given transport\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n\n\n  maybeUpgrade(transport) {\n    debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n    this.upgrading = true;\n    const self = this; // set transport upgrade timer\n\n    self.upgradeTimeoutTimer = setTimeout(function () {\n      debug(\"client did not complete upgrade - closing transport\");\n      cleanup();\n\n      if (\"open\" === transport.readyState) {\n        transport.close();\n      }\n    }, this.server.opts.upgradeTimeout);\n\n    function onPacket(packet) {\n      if (\"ping\" === packet.type && \"probe\" === packet.data) {\n        transport.send([{\n          type: \"pong\",\n          data: \"probe\"\n        }]);\n        self.emit(\"upgrading\", transport);\n        clearInterval(self.checkIntervalTimer);\n        self.checkIntervalTimer = setInterval(check, 100);\n      } else if (\"upgrade\" === packet.type && self.readyState !== \"closed\") {\n        debug(\"got upgrade packet - upgrading\");\n        cleanup();\n        self.transport.discard();\n        self.upgraded = true;\n        self.clearTransport();\n        self.setTransport(transport);\n        self.emit(\"upgrade\", transport);\n        self.schedulePing();\n        self.flush();\n\n        if (self.readyState === \"closing\") {\n          transport.close(function () {\n            self.onClose(\"forced close\");\n          });\n        }\n      } else {\n        cleanup();\n        transport.close();\n      }\n    } // we force a polling cycle to ensure a fast upgrade\n\n\n    function check() {\n      if (\"polling\" === self.transport.name && self.transport.writable) {\n        debug(\"writing a noop packet to polling for fast upgrade\");\n        self.transport.send([{\n          type: \"noop\"\n        }]);\n      }\n    }\n\n    function cleanup() {\n      self.upgrading = false;\n      clearInterval(self.checkIntervalTimer);\n      self.checkIntervalTimer = null;\n      clearTimeout(self.upgradeTimeoutTimer);\n      self.upgradeTimeoutTimer = null;\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"close\", onTransportClose);\n      transport.removeListener(\"error\", onError);\n      self.removeListener(\"close\", onClose);\n    }\n\n    function onError(err) {\n      debug(\"client did not complete upgrade - %s\", err);\n      cleanup();\n      transport.close();\n      transport = null;\n    }\n\n    function onTransportClose() {\n      onError(\"transport closed\");\n    }\n\n    function onClose() {\n      onError(\"socket closed\");\n    }\n\n    transport.on(\"packet\", onPacket);\n    transport.once(\"close\", onTransportClose);\n    transport.once(\"error\", onError);\n    self.once(\"close\", onClose);\n  }\n  /**\n   * Clears listeners and timers associated with current transport.\n   *\n   * @api private\n   */\n\n\n  clearTransport() {\n    let cleanup;\n    const toCleanUp = this.cleanupFn.length;\n\n    for (let i = 0; i < toCleanUp; i++) {\n      cleanup = this.cleanupFn.shift();\n      cleanup();\n    } // silence further transport errors and prevent uncaught exceptions\n\n\n    this.transport.on(\"error\", function () {\n      debug(\"error triggered by discarded transport\");\n    }); // ensure transport won't stay open\n\n    this.transport.close();\n    clearTimeout(this.pingTimeoutTimer);\n  }\n  /**\n   * Called upon transport considered closed.\n   * Possible reasons: `ping timeout`, `client error`, `parse error`,\n   * `transport error`, `server close`, `transport close`\n   */\n\n\n  onClose(reason, description) {\n    if (\"closed\" !== this.readyState) {\n      this.readyState = \"closed\"; // clear timers\n\n      clearTimeout(this.pingIntervalTimer);\n      clearTimeout(this.pingTimeoutTimer);\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      clearTimeout(this.upgradeTimeoutTimer);\n      const self = this; // clean writeBuffer in next tick, so developers can still\n      // grab the writeBuffer on 'close' event\n\n      process.nextTick(function () {\n        self.writeBuffer = [];\n      });\n      this.packetsFn = [];\n      this.sentCallbackFn = [];\n      this.clearTransport();\n      this.emit(\"close\", reason, description);\n    }\n  }\n  /**\n   * Setup and manage send callback\n   *\n   * @api private\n   */\n\n\n  setupSendCallback() {\n    const self = this;\n    this.transport.on(\"drain\", onDrain);\n    this.cleanupFn.push(function () {\n      self.transport.removeListener(\"drain\", onDrain);\n    }); // the message was sent successfully, execute the callback\n\n    function onDrain() {\n      if (self.sentCallbackFn.length > 0) {\n        const seqFn = self.sentCallbackFn.splice(0, 1)[0];\n\n        if (\"function\" === typeof seqFn) {\n          debug(\"executing send callback\");\n          seqFn(self.transport);\n        } else if (Array.isArray(seqFn)) {\n          debug(\"executing batch send callback\");\n          const l = seqFn.length;\n          let i = 0;\n\n          for (; i < l; i++) {\n            if (\"function\" === typeof seqFn[i]) {\n              seqFn[i](self.transport);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Sends a message packet.\n   *\n   * @param {String} message\n   * @param {Object} options\n   * @param {Function} callback\n   * @return {Socket} for chaining\n   * @api public\n   */\n\n\n  send(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  write(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} packet type\n   * @param {String} optional, data\n   * @param {Object} options\n   * @api private\n   */\n\n\n  sendPacket(type, data, options, callback) {\n    if (\"function\" === typeof options) {\n      callback = options;\n      options = null;\n    }\n\n    options = options || {};\n    options.compress = false !== options.compress;\n\n    if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n      debug('sending packet \"%s\" (%s)', type, data);\n      const packet = {\n        type: type,\n        options: options\n      };\n      if (data) packet.data = data; // exports packetCreate event\n\n      this.emit(\"packetCreate\", packet);\n      this.writeBuffer.push(packet); // add send callback to object, if defined\n\n      if (callback) this.packetsFn.push(callback);\n      this.flush();\n    }\n  }\n  /**\n   * Attempts to flush the packets buffer.\n   *\n   * @api private\n   */\n\n\n  flush() {\n    if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n      debug(\"flushing buffer to transport\");\n      this.emit(\"flush\", this.writeBuffer);\n      this.server.emit(\"flush\", this, this.writeBuffer);\n      const wbuf = this.writeBuffer;\n      this.writeBuffer = [];\n\n      if (!this.transport.supportsFraming) {\n        this.sentCallbackFn.push(this.packetsFn);\n      } else {\n        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n      }\n\n      this.packetsFn = [];\n      this.transport.send(wbuf);\n      this.emit(\"drain\");\n      this.server.emit(\"drain\", this);\n    }\n  }\n  /**\n   * Get available upgrades for this socket.\n   *\n   * @api private\n   */\n\n\n  getAvailableUpgrades() {\n    const availableUpgrades = [];\n    const allUpgrades = this.server.upgrades(this.transport.name);\n    let i = 0;\n    const l = allUpgrades.length;\n\n    for (; i < l; ++i) {\n      const upg = allUpgrades[i];\n\n      if (this.server.opts.transports.indexOf(upg) !== -1) {\n        availableUpgrades.push(upg);\n      }\n    }\n\n    return availableUpgrades;\n  }\n  /**\n   * Closes the socket and underlying transport.\n   *\n   * @param {Boolean} optional, discard\n   * @return {Socket} for chaining\n   * @api public\n   */\n\n\n  close(discard) {\n    if (\"open\" !== this.readyState) return;\n    this.readyState = \"closing\";\n\n    if (this.writeBuffer.length) {\n      this.once(\"drain\", this.closeTransport.bind(this, discard));\n      return;\n    }\n\n    this.closeTransport(discard);\n  }\n  /**\n   * Closes the underlying transport.\n   *\n   * @param {Boolean} discard\n   * @api private\n   */\n\n\n  closeTransport(discard) {\n    if (discard) this.transport.discard();\n    this.transport.close(this.onClose.bind(this, \"forced close\"));\n  }\n\n}\n\nmodule.exports = Socket;","map":null,"metadata":{},"sourceType":"script"}