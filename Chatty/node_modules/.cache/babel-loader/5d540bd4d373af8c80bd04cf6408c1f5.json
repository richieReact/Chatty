{"ast":null,"code":"const Transport = require(\"../transport\");\n\nconst parser = require(\"engine.io-parser\");\n\nconst debug = require(\"debug\")(\"engine:ws\");\n\nclass WebSocket extends Transport {\n  /**\n   * WebSocket transport\n   *\n   * @param {http.IncomingMessage}\n   * @api public\n   */\n  constructor(req) {\n    super(req);\n    this.socket = req.websocket;\n    this.socket.on(\"message\", this.onData.bind(this));\n    this.socket.once(\"close\", this.onClose.bind(this));\n    this.socket.on(\"error\", this.onError.bind(this));\n    this.socket.on(\"headers\", headers => {\n      this.emit(\"headers\", headers);\n    });\n    this.writable = true;\n    this.perMessageDeflate = null;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"websocket\";\n  }\n  /**\n   * Advertise upgrade support.\n   *\n   * @api public\n   */\n\n\n  get handlesUpgrades() {\n    return true;\n  }\n  /**\n   * Advertise framing support.\n   *\n   * @api public\n   */\n\n\n  get supportsFraming() {\n    return true;\n  }\n  /**\n   * Processes the incoming data.\n   *\n   * @param {String} encoded packet\n   * @api private\n   */\n\n\n  onData(data) {\n    debug('received \"%s\"', data);\n    super.onData(data);\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Array} packets\n   * @api private\n   */\n\n\n  send(packets) {\n    var self = this;\n\n    for (var i = 0; i < packets.length; i++) {\n      var packet = packets[i];\n      parser.encodePacket(packet, self.supportsBinary, send);\n    }\n\n    function send(data) {\n      debug('writing \"%s\"', data); // always creates a new object since ws modifies it\n\n      var opts = {};\n\n      if (packet.options) {\n        opts.compress = packet.options.compress;\n      }\n\n      if (self.perMessageDeflate) {\n        var len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n\n        if (len < self.perMessageDeflate.threshold) {\n          opts.compress = false;\n        }\n      }\n\n      self.writable = false;\n      self.socket.send(data, opts, onEnd);\n    }\n\n    function onEnd(err) {\n      if (err) return self.onError(\"write error\", err.stack);\n      self.writable = true;\n      self.emit(\"drain\");\n    }\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n\n\n  doClose(fn) {\n    debug(\"closing\");\n    this.socket.close();\n    fn && fn();\n  }\n\n}\n\nmodule.exports = WebSocket;","map":null,"metadata":{},"sourceType":"script"}