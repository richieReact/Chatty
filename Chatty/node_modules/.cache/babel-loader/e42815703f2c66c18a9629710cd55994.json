{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Namespace = exports.Socket = exports.Server = void 0;\n\nconst http = require(\"http\");\n\nconst fs_1 = require(\"fs\");\n\nconst zlib_1 = require(\"zlib\");\n\nconst accepts = require(\"accepts\");\n\nconst stream_1 = require(\"stream\");\n\nconst path = require(\"path\");\n\nconst engine = require(\"engine.io\");\n\nconst client_1 = require(\"./client\");\n\nconst events_1 = require(\"events\");\n\nconst namespace_1 = require(\"./namespace\");\n\nObject.defineProperty(exports, \"Namespace\", {\n  enumerable: true,\n  get: function () {\n    return namespace_1.Namespace;\n  }\n});\n\nconst parent_namespace_1 = require(\"./parent-namespace\");\n\nconst socket_io_adapter_1 = require(\"socket.io-adapter\");\n\nconst parser = __importStar(require(\"socket.io-parser\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst socket_1 = require(\"./socket\");\n\nObject.defineProperty(exports, \"Socket\", {\n  enumerable: true,\n  get: function () {\n    return socket_1.Socket;\n  }\n});\nconst debug = debug_1.default(\"socket.io:server\");\n\nconst clientVersion = require(\"../package.json\").version;\n\nconst dotMapRegex = /\\.map/;\n\nclass Server extends events_1.EventEmitter {\n  constructor(srv, opts = {}) {\n    super();\n    /**\n     * @private\n     */\n\n    this._nsps = new Map();\n    this.parentNsps = new Map();\n\n    if (\"object\" == typeof srv && srv instanceof Object && !srv.listen) {\n      opts = srv;\n      srv = null;\n    }\n\n    this.path(opts.path || \"/socket.io\");\n    this.connectTimeout(opts.connectTimeout || 45000);\n    this.serveClient(false !== opts.serveClient);\n    this._parser = opts.parser || parser;\n    this.encoder = new this._parser.Encoder();\n    this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n    this.sockets = this.of(\"/\");\n    if (srv) this.attach(srv, opts);\n  }\n\n  serveClient(v) {\n    if (!arguments.length) return this._serveClient;\n    this._serveClient = v;\n    return this;\n  }\n  /**\n   * Executes the middleware for an incoming namespace not already created on the server.\n   *\n   * @param {String} name - name of incoming namespace\n   * @param {Object} auth - the auth parameters\n   * @param {Function} fn - callback\n   *\n   * @private\n   */\n\n\n  _checkNamespace(name, auth, fn) {\n    if (this.parentNsps.size === 0) return fn(false);\n    const keysIterator = this.parentNsps.keys();\n\n    const run = () => {\n      let nextFn = keysIterator.next();\n\n      if (nextFn.done) {\n        return fn(false);\n      }\n\n      nextFn.value(name, auth, (err, allow) => {\n        if (err || !allow) {\n          run();\n        } else {\n          fn(this.parentNsps.get(nextFn.value).createChild(name));\n        }\n      });\n    };\n\n    run();\n  }\n\n  path(v) {\n    if (!arguments.length) return this._path;\n    this._path = v.replace(/\\/$/, \"\");\n\n    const escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\n    this.clientPathRegex = new RegExp(\"^\" + escapedPath + \"/socket\\\\.io(\\\\.min|\\\\.msgpack\\\\.min)?\\\\.js(\\\\.map)?$\");\n    return this;\n  }\n\n  connectTimeout(v) {\n    if (v === undefined) return this._connectTimeout;\n    this._connectTimeout = v;\n    return this;\n  }\n\n  adapter(v) {\n    if (!arguments.length) return this._adapter;\n    this._adapter = v;\n\n    for (const nsp of this._nsps.values()) {\n      nsp._initAdapter();\n    }\n\n    return this;\n  }\n\n  listen(srv, opts = {}) {\n    return this.attach(srv, opts);\n  }\n\n  attach(srv, opts = {}) {\n    if (\"function\" == typeof srv) {\n      const msg = \"You are trying to attach socket.io to an express \" + \"request handler function. Please pass a http.Server instance.\";\n      throw new Error(msg);\n    } // handle a port as a string\n\n\n    if (Number(srv) == srv) {\n      srv = Number(srv);\n    }\n\n    if (\"number\" == typeof srv) {\n      debug(\"creating http server and binding to %d\", srv);\n      const port = srv;\n      srv = http.createServer((req, res) => {\n        res.writeHead(404);\n        res.end();\n      });\n      srv.listen(port);\n    } // set engine.io path to `/socket.io`\n\n\n    opts.path = opts.path || this._path;\n    this.initEngine(srv, opts);\n    return this;\n  }\n  /**\n   * Initialize engine\n   *\n   * @param srv - the server to attach to\n   * @param opts - options passed to engine.io\n   * @private\n   */\n\n\n  initEngine(srv, opts) {\n    // initialize engine\n    debug(\"creating engine.io instance with opts %j\", opts);\n    this.eio = engine.attach(srv, opts); // attach static file serving\n\n    if (this._serveClient) this.attachServe(srv); // Export http server\n\n    this.httpServer = srv; // bind to engine events\n\n    this.bind(this.eio);\n  }\n  /**\n   * Attaches the static file serving.\n   *\n   * @param {Function|http.Server} srv http server\n   * @private\n   */\n\n\n  attachServe(srv) {\n    debug(\"attaching client serving req handler\");\n    const evs = srv.listeners(\"request\").slice(0);\n    srv.removeAllListeners(\"request\");\n    srv.on(\"request\", (req, res) => {\n      if (this.clientPathRegex.test(req.url)) {\n        this.serve(req, res);\n      } else {\n        for (let i = 0; i < evs.length; i++) {\n          evs[i].call(srv, req, res);\n        }\n      }\n    });\n  }\n  /**\n   * Handles a request serving of client source and map\n   *\n   * @param {http.IncomingMessage} req\n   * @param {http.ServerResponse} res\n   * @private\n   */\n\n\n  serve(req, res) {\n    const filename = req.url.replace(this._path, \"\");\n    const isMap = dotMapRegex.test(filename);\n    const type = isMap ? \"map\" : \"source\"; // Per the standard, ETags must be quoted:\n    // https://tools.ietf.org/html/rfc7232#section-2.3\n\n    const expectedEtag = '\"' + clientVersion + '\"';\n    const etag = req.headers[\"if-none-match\"];\n\n    if (etag) {\n      if (expectedEtag == etag) {\n        debug(\"serve client %s 304\", type);\n        res.writeHead(304);\n        res.end();\n        return;\n      }\n    }\n\n    debug(\"serve client %s\", type);\n    res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n    res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\"));\n    res.setHeader(\"ETag\", expectedEtag);\n\n    if (!isMap) {\n      res.setHeader(\"X-SourceMap\", filename.substring(1) + \".map\");\n    }\n\n    Server.sendFile(filename, req, res);\n  }\n  /**\n   * @param filename\n   * @param req\n   * @param res\n   * @private\n   */\n\n\n  static sendFile(filename, req, res) {\n    const readStream = fs_1.createReadStream(path.join(__dirname, \"../client-dist/\", filename));\n    const encoding = accepts(req).encodings([\"br\", \"gzip\", \"deflate\"]);\n\n    const onError = err => {\n      if (err) {\n        res.end();\n      }\n    };\n\n    switch (encoding) {\n      case \"br\":\n        res.writeHead(200, {\n          \"content-encoding\": \"br\"\n        });\n        readStream.pipe(zlib_1.createBrotliCompress()).pipe(res);\n        stream_1.pipeline(readStream, zlib_1.createBrotliCompress(), res, onError);\n        break;\n\n      case \"gzip\":\n        res.writeHead(200, {\n          \"content-encoding\": \"gzip\"\n        });\n        stream_1.pipeline(readStream, zlib_1.createGzip(), res, onError);\n        break;\n\n      case \"deflate\":\n        res.writeHead(200, {\n          \"content-encoding\": \"deflate\"\n        });\n        stream_1.pipeline(readStream, zlib_1.createDeflate(), res, onError);\n        break;\n\n      default:\n        res.writeHead(200);\n        stream_1.pipeline(readStream, res, onError);\n    }\n  }\n  /**\n   * Binds socket.io to an engine.io instance.\n   *\n   * @param {engine.Server} engine engine.io (or compatible) server\n   * @return {Server} self\n   * @public\n   */\n\n\n  bind(engine) {\n    this.engine = engine;\n    this.engine.on(\"connection\", this.onconnection.bind(this));\n    return this;\n  }\n  /**\n   * Called with each incoming transport connection.\n   *\n   * @param {engine.Socket} conn\n   * @return {Server} self\n   * @private\n   */\n\n\n  onconnection(conn) {\n    debug(\"incoming connection with id %s\", conn.id);\n    new client_1.Client(this, conn);\n    return this;\n  }\n  /**\n   * Looks up a namespace.\n   *\n   * @param {String|RegExp|Function} name nsp name\n   * @param {Function} [fn] optional, nsp `connection` ev handler\n   * @public\n   */\n\n\n  of(name, fn) {\n    if (typeof name === \"function\" || name instanceof RegExp) {\n      const parentNsp = new parent_namespace_1.ParentNamespace(this);\n      debug(\"initializing parent namespace %s\", parentNsp.name);\n\n      if (typeof name === \"function\") {\n        this.parentNsps.set(name, parentNsp);\n      } else {\n        this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);\n      }\n\n      if (fn) {\n        // @ts-ignore\n        parentNsp.on(\"connect\", fn);\n      }\n\n      return parentNsp;\n    }\n\n    if (String(name)[0] !== \"/\") name = \"/\" + name;\n\n    let nsp = this._nsps.get(name);\n\n    if (!nsp) {\n      debug(\"initializing namespace %s\", name);\n      nsp = new namespace_1.Namespace(this, name);\n\n      this._nsps.set(name, nsp);\n    }\n\n    if (fn) nsp.on(\"connect\", fn);\n    return nsp;\n  }\n  /**\n   * Closes server connection\n   *\n   * @param {Function} [fn] optional, called as `fn([err])` on error OR all conns closed\n   * @public\n   */\n\n\n  close(fn) {\n    for (const socket of this.sockets.sockets.values()) {\n      socket._onclose(\"server shutting down\");\n    }\n\n    this.engine.close();\n\n    if (this.httpServer) {\n      this.httpServer.close(fn);\n    } else {\n      fn && fn();\n    }\n  }\n  /**\n   * Sets up namespace middleware.\n   *\n   * @return {Server} self\n   * @public\n   */\n\n\n  use(fn) {\n    this.sockets.use(fn);\n    return this;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param {String} name\n   * @return {Server} self\n   * @public\n   */\n\n\n  to(name) {\n    this.sockets.to(name);\n    return this;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param {String} name\n   * @return {Server} self\n   * @public\n   */\n\n\n  in(name) {\n    this.sockets.in(name);\n    return this;\n  }\n  /**\n   * Sends a `message` event to all clients.\n   *\n   * @return {Server} self\n   * @public\n   */\n\n\n  send(...args) {\n    args.unshift(\"message\");\n    this.sockets.emit.apply(this.sockets, args);\n    return this;\n  }\n  /**\n   * Sends a `message` event to all clients.\n   *\n   * @return {Server} self\n   * @public\n   */\n\n\n  write(...args) {\n    args.unshift(\"message\");\n    this.sockets.emit.apply(this.sockets, args);\n    return this;\n  }\n  /**\n   * Gets a list of socket ids.\n   *\n   * @public\n   */\n\n\n  allSockets() {\n    return this.sockets.allSockets();\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param {Boolean} compress - if `true`, compresses the sending data\n   * @return {Server} self\n   * @public\n   */\n\n\n  compress(compress) {\n    this.sockets.compress(compress);\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @return {Server} self\n   * @public\n   */\n\n\n  get volatile() {\n    this.sockets.volatile;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @return {Server} self\n   * @public\n   */\n\n\n  get local() {\n    this.sockets.local;\n    return this;\n  }\n\n}\n\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */\n\nconst emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {\n  return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function (fn) {\n  Server.prototype[fn] = function () {\n    return this.sockets[fn].apply(this.sockets, arguments);\n  };\n});\n\nmodule.exports = (srv, opts) => new Server(srv, opts);\n\nmodule.exports.Server = Server;","map":null,"metadata":{},"sourceType":"script"}